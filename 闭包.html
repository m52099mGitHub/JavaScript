<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>闭包</title>
</head>
<body>
<h2>点击每一列获取其索引值</h2>
<ul id="test">
	<li>NO.1</li>
	<li>NO.2</li>
	<li>NO.3</li>
	<li>No.4</li>
</ul>
	<!-- 
	<script>
		//方法1
		var oUl=document.getElementById("test");
		var aList=oUl.getElementsByTagName("li");
		for(var i=0;i<4;i++){
			aList[i].index=i;
			aList[i].onclick=function(){
				alert(this.index);
			};
		}
	</script>
	 -->
	
	<script>
		/*var Oul=document.getElementById("test");
		var aList=document.getElementsByTagName("li");
		for(var i=0;i<aList.length;i++){
			aList[i].onclick=function(a){
				return function(){
					alert(a);
				}
			}(i);
		}*/
	</script>


	<script>
		/*var generateClosure=function(){
	    var count=0;
	    var get=function(){
	    count++;
	    return count;
	         };
	    return get;
	};
		var counter=generateClosure();
		console.log(counter());   //   输出   1
		console.log(counter());   //   输出   2
		console.log(counter()); */  //   输出   3
		/*
		这段代码中，generateClosure() 函数中有一个局部变量count，初值为 0。还有一个叫做 get 的函数，get 将其父作用域，也就是 generateClosure()函数中的 count变量增加 1，并返回 count 的值。generateClosure() 的返回值是 get 函数。在外部我们通过 counter变量调用了 generateClosure() 函数并获取了它的返回值，也就是 get 函数，接下来反复调用几次 counter()，我们发现每次返回的值都递增了1。

让我们看看上面的例子有什么特点，按照通常命令式编程思维的理解，count 是generateClosure 函数内部的变量，它的生命周期就是 generateClosure 被调用的时期，当 generateClosure 从调用栈中返回时，count 变量申请的空间也就被释放。问题是，generateClosure() 调用结束后，counter() 却引用了“已经释放了的” count变量，而且非但没有出错，反而每次调用 counter() 时还修改并返回了 count。这是怎么回事呢？
这正是所谓闭包的特性。当一个函数返回它内部定义的一个函数时，就产生了一个闭包，闭包不但包括被返回的函数，还包括这个函数的定义环境。上面例子中，当函数generateClosure() 的内部函数 get 被一个外部变量 counter 引用时，counter 和generateClosure()的局部变量就是一个闭包


		 */
	</script>

	<script>
		for(var i=0;i<5;i++)
		{
			setTimeout(function(){
				console.log(i);
			},i*1000);
		}
	</script>
</body>
</html>